# Manual Generation

This module shows how you can make use of an annotation processor
by generating a new source file which will then be included in the compilation
process, generating a new source file.

If you check the AnnotatedStudent.java file, you can see that it does
not have a toString() method, but the class is annotated with @CustomToString.
This is a custom annotation  that will generate a  toString() method and replace
it if an existing one is already declared.

## Testing

If you check out the Main.java file, you can see that there is a commented import
and that the file raises some errors in the IDE. This is because
generated.AnnotatedStudent does not exist in the source code. It is something
that we expect the CustomToStringProcessor to generate.

Once you compile the module, the errors should disappear because
the .class file is generated. You can check this in target\classes\generated.
It should have a toString() method like so.
```
public String toString() {
    return "name: " + this.name + ", email: " + this.email;
}
```
And if you check the original source file in src\main\java and the .class file in 
target\classes, you can see that they both do not have the toString() method.

This .class file is actually not generated from the source code. This is generated from
the .java file generated by the annotation processor that you can find in
target\generated-sources\annotations. This means that with this method of annotation processing,
we are generating an extra .java file and .class file in the compiled output, which is
not a good thing especially on a larger scale.

Therefore, when you run Main.java, you can also see that the printed result for
Student and AnnotatedStudent are the same in the sense that they print the memory address, 
but the result for generated.AnnotatedStudent is different.
```
Student@74a14482
AnnotatedStudent@1540e19d
name: Joshua (Generated), email: joshuaxu71@gmail.com
```

And if we uncomment the import in Main.java, then the AnnotatedStudent will
automatically use generated.AnnotatedStudent as well because they have the same name.
```
Student@74a14482
name: Joshua, email: joshuaxu71@gmail.com
name: Joshua (Generated), email: joshuaxu71@gmail.com
```
This wasn't really expected during development, but with this finding, it means that
we don't really need to write generated.AnnotatedStudent in Main.java, and can just use
AnnotatedStudent.

Now if add a toString() method in the AnnotatedStudent.java file
```
public String toString() {
    return "original name: " + this.name + ", email: " + this.email;
}
```

And if we compile and run Main.java again, then we can see that the original
AnnotatedStudent's toString() method will not be affected, while the generated
AnnotatedStudent's will be updated
```
Student@74a14482
original name: Joshua, email: joshuaxu71@gmail.com
name: Joshua (Generated), email: joshuaxu71@gmail.com
```